// Generated by the Freon Language Generator.
import { PropertiesEveryConcept } from "../../language/gen";
import { StringValue, IntValue, DecValue, BooleanValue, Value, Property, PropertiesFile, MainModel } from "../../language/gen";
import { PropertiesWorker } from "./PropertiesWorker";
import { FreLogger } from "@freon4dsl/core";

const LOGGER = new FreLogger("PropertiesWalker");

/**
 * Class PropertiesWalker implements the extended visitor pattern of instances of language properties.
 * This class implements the traversal of the model tree, classes that implement PropertiesWorker
 * are responsible for the actual work being done on the nodes of the tree.
 * Every node is visited twice, once before the visit of its children, and once after this visit.
 *
 * With the use of the parameter 'includeChildren', which takes a function, a very fine-grained control can be taken
 * over which nodes are and are not visited.
 */
export class PropertiesWalker {
    myWorkers: PropertiesWorker[] = []; // the instances that do the actual work on each node of the tree

    /**
     * This method is the entry point of the traversal through the model tree. Each of the workers will be called in
     * the order in which they are present in the array 'myWorkers'. If, for a tree node, a worker returns 'false',
     * none of the rest of the workers will be called. For that particular node both the 'execBefore' and 'execAfter'
     * method of any of the other workers will be skipped.
     *
     * @param modelelement the top node of the part of the tree to be visited
     * @param includeChildren if true, the children of 'modelelement' will also be visited
     */
    public walk(modelelement: PropertiesEveryConcept, includeChildren?: (elem: PropertiesEveryConcept) => boolean) {
        if (this.myWorkers.length > 0) {
            if (modelelement instanceof StringValue) {
                return this.walkStringValue(modelelement, includeChildren);
            }
            if (modelelement instanceof IntValue) {
                return this.walkIntValue(modelelement, includeChildren);
            }
            if (modelelement instanceof DecValue) {
                return this.walkDecValue(modelelement, includeChildren);
            }
            if (modelelement instanceof BooleanValue) {
                return this.walkBooleanValue(modelelement, includeChildren);
            }
            if (modelelement instanceof Value) {
                return this.walkValue(modelelement, includeChildren);
            }
            if (modelelement instanceof Property) {
                return this.walkProperty(modelelement, includeChildren);
            }
            if (modelelement instanceof PropertiesFile) {
                return this.walkPropertiesFile(modelelement, includeChildren);
            }
            if (modelelement instanceof MainModel) {
                return this.walkMainModel(modelelement, includeChildren);
            }
        } else {
            LOGGER.error("No worker found.");
        }
    }

    private walkStringValue(modelelement: StringValue, includeChildren?: (elem: PropertiesEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeStringValue(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterStringValue(modelelement);
            }
        }
    }

    private walkIntValue(modelelement: IntValue, includeChildren?: (elem: PropertiesEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeIntValue(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterIntValue(modelelement);
            }
        }
    }

    private walkDecValue(modelelement: DecValue, includeChildren?: (elem: PropertiesEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeDecValue(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterDecValue(modelelement);
            }
        }
    }

    private walkBooleanValue(modelelement: BooleanValue, includeChildren?: (elem: PropertiesEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeBooleanValue(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterBooleanValue(modelelement);
            }
        }
    }

    private walkValue(modelelement: Value, includeChildren?: (elem: PropertiesEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeValue(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterValue(modelelement);
            }
        }
    }

    private walkProperty(modelelement: Property, includeChildren?: (elem: PropertiesEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeProperty(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.value)) {
            this.walk(modelelement.value, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterProperty(modelelement);
            }
        }
    }

    private walkPropertiesFile(modelelement: PropertiesFile, includeChildren?: (elem: PropertiesEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforePropertiesFile(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.props.forEach(p => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterPropertiesFile(modelelement);
            }
        }
    }

    private walkMainModel(modelelement: MainModel, includeChildren?: (elem: PropertiesEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeMainModel(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.files.forEach(p => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterMainModel(modelelement);
            }
        }
    }
}
