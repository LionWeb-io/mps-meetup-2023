// Generated by the Freon Language Generator.
import { net } from "net.akehurst.language-agl-processor";
import SPPTBranch = net.akehurst.language.api.sppt.SPPTBranch;
import { PropertiesFile, Property, BooleanValue, DecValue, IntValue, StringValue, Value } from "../../language/gen";
import { PropertiesSyntaxAnalyser } from "./PropertiesSyntaxAnalyser";
import { FreNodeReference } from "@freon4dsl/core";

export class PropertiesFileSyntaxAnalyserPart {
    mainAnalyser: PropertiesSyntaxAnalyser;

    constructor(mainAnalyser: PropertiesSyntaxAnalyser) {
        this.mainAnalyser = mainAnalyser;
    }

    /**
     * Method to transform branches that match the following rule:
     * PropertiesFile = 'PropertiesFile' identifier '\{'
     *	 'props'
     *	 Property*
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformPropertiesFile(branch: SPPTBranch): PropertiesFile {
        // console.log('transformPropertiesFile called: ' + branch.name);
        let __name: string;
        let __props: Property[];
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        // RHSPartListEntry
        if (children[4].name !== "Property") {
            __props = this.mainAnalyser.transformSharedPackedParseTreeList<Property>(children[4]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __props = [];
            for (const child of children) {
                __props.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return PropertiesFile.create({
            name: __name,
            props: __props,
            parseLocation: this.mainAnalyser.location(branch)
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * Property = 'Property' identifier '\{'
     *	 'value' Value
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformProperty(branch: SPPTBranch): Property {
        // console.log('transformProperty called: ' + branch.name);
        let __name: string;
        let __value: Value;
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        __value = this.mainAnalyser.transformSharedPackedParseTreeNode(children[4]); // RHSPartEntry

        return Property.create({
            name: __name,
            value: __value,
            parseLocation: this.mainAnalyser.location(branch)
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * BooleanValue = 'BooleanValue' '\{'
     *	 'value' booleanLiteral
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformBooleanValue(branch: SPPTBranch): BooleanValue {
        // console.log('transformBooleanValue called: ' + branch.name);
        let __value: boolean;
        const children = this.mainAnalyser.getChildren(branch);
        __value = this.mainAnalyser.transformSharedPackedParseTreeNode(children[3]); // RHSPrimEntry

        return BooleanValue.create({
            value: __value,
            parseLocation: this.mainAnalyser.location(branch)
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * DecValue = 'DecValue' '\{'
     *	 'value' stringLiteral
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformDecValue(branch: SPPTBranch): DecValue {
        // console.log('transformDecValue called: ' + branch.name);
        let __value: string;
        const children = this.mainAnalyser.getChildren(branch);
        __value = this.mainAnalyser.transformSharedPackedParseTreeNode(children[3]); // RHSPrimEntry

        return DecValue.create({
            value: __value,
            parseLocation: this.mainAnalyser.location(branch)
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * IntValue = 'IntValue' '\{'
     *	 'value' stringLiteral
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformIntValue(branch: SPPTBranch): IntValue {
        // console.log('transformIntValue called: ' + branch.name);
        let __value: string;
        const children = this.mainAnalyser.getChildren(branch);
        __value = this.mainAnalyser.transformSharedPackedParseTreeNode(children[3]); // RHSPrimEntry

        return IntValue.create({
            value: __value,
            parseLocation: this.mainAnalyser.location(branch)
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * StringValue = 'StringValue' '\{'
     *	 'value' stringLiteral
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformStringValue(branch: SPPTBranch): StringValue {
        // console.log('transformStringValue called: ' + branch.name);
        let __value: string;
        const children = this.mainAnalyser.getChildren(branch);
        __value = this.mainAnalyser.transformSharedPackedParseTreeNode(children[3]); // RHSPrimEntry

        return StringValue.create({
            value: __value,
            parseLocation: this.mainAnalyser.location(branch)
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * Value = BooleanValue
     *    | DecValue
     *    | IntValue
     *    | StringValue  ;
     * @param branch
     * @private
     */
    public transformValue(branch: SPPTBranch): Value {
        // console.log('transformValue called: ' + branch.name);
        return this.mainAnalyser.transformSharedPackedParseTreeNode(branch.nonSkipChildren.toArray()[0]);
    }
}
